angular.js

Property binding // event binding // String interpolation 

two way data binding - [(ngModel)] = “typescriptVar” —> {{typescriptVar}}

*ngIf = "boolean expression"  (* for structural directives)
*ngIf = "" else noServer   <ng-template #noServer> 

[ngStyle] = "{'color': 'red'}"  
[ngStyle] = "{'color': getColor()}"  --> typescript return something
[ngClass] = "{css class name: boolean}" if true, class is attached
*ngFor = "let variable of typescriptVar"
*ngFor = "let variable of typescriptVar; let i = index"

custom property  html --> serverElement   [element] (defined in child) = "serverElement" typescript --> @input('alias') element() (viewable from parent component)

event binding custom (customEvent) = "parentMethod(event)"   typescript--> parentMethod(event) {}  child typescript --> @output (passing events outside of component) customEvent = new eventemitter<{$event data}>  onChildMethod  this.customEvent.emit(@event data)

component --> viewencapsulation.none for when css is universal

local reference --> # (template only such as passing data or $event) typescript --> method(input: htmlinputelement)

@viewchild('selector || local reference') variable: elementref      typescript --> this.variable.nativelement.value  

<ng-content> info is now projected from child template to parent template

typescript --> @contentchild('content') variable: elementref


new attribute directive (add to module to declarations + shared module)

@directive({
    selector:[],
})
export class directive  implements oninit{
    constructor(private elementref: elementref,private renderer: renderer) {}
    ngoninit() {this.renderer.setstyle(this.elementref.nativelement, 'color', 'green')}

    @hostbinding('style.backgroundcolor') backgroundColor: string = transparent;

    @hostlistener('mouseenter') mouseover(eventdata: event) {
        this.renderer.setstyle(this.elementref.nativelement, 'color', 'blue');
    }

}

new structural directive 
@input() set unless(condition: boolean) {
    if(!condition) {
        this.vcref.createembeddedview(this.templateref);
    } else {
        this.vcref.clear
    }

    contructor(private templateref: templateref<any>, private vcref: viewconainerref) {

    }
}


SERVICE (less repetition and data passing easy )
export class Service {
    logStatusChange(status: string) {
        console.log(status);
    }
}

to import service --> put into constructor of component (private service: Service) & add service to providors array